package assets

import (
	"bytes"
	"crypto/md5"
	"fmt"
	"io"
	"log"
	"os"
	"path/filepath"
	"strings"
)

func CreateManifest() {
	srcDir := "assets/src"
	fileMap := make(map[string]string)
	out := &bytes.Buffer{}
	outputFile := "assets/generated-asset-map.go"

	// Process directory recursively
	err := processDirectory(srcDir, srcDir, fileMap)
	if err != nil {
		log.Fatalf("Error processing directory: %v", err)
	}
	fmt.Fprintln(out, "package assets")
	fmt.Fprintln(out, "")
	fmt.Fprintln(out, "// Code generated by go:generate; DO NOT EDIT.")
	fmt.Fprintln(out, "")
	fmt.Fprintln(out, "var assetMap = map[string]string{")
	for k, v := range fileMap {
		fmt.Fprintf(out, "\t\"%s\":\"%s\",\n", k, v)
	}
	fmt.Fprintln(out, "}")
	fmt.Fprintln(out, `
	func Path(path string) string {
		if hash, ok := assetMap[path]; ok {
			return hash
		}
		return "/" + path
	}
	`)
	os.WriteFile(outputFile, out.Bytes(), 0644)
	copyFingerprinted(fileMap)

	fmt.Printf("Successfully created %s with %d files\n", outputFile, len(fileMap))
}

func processDirectory(rootDir, currentDir string, fileMap map[string]string) error {
	// Read all files and directories in the current directory
	entries, err := os.ReadDir(currentDir)
	if err != nil {
		return fmt.Errorf("error reading directory %s: %v", currentDir, err)
	}

	for _, entry := range entries {
		// Get the full path
		fullPath := filepath.Join(currentDir, entry.Name())
		// Get the relative path from root directory
		relativePath, err := filepath.Rel(rootDir, fullPath)
		if err != nil {
			return fmt.Errorf("error getting relative path for %s: %v", fullPath, err)
		}

		if entry.IsDir() {
			// Recursively process subdirectories
			err = processDirectory(rootDir, fullPath, fileMap)
			if err != nil {
				return err
			}
		} else {
			// Process files
			file, err := os.Open(fullPath)
			if err != nil {
				return fmt.Errorf("error opening file %s: %v", fullPath, err)
			}
			defer file.Close()

			// Create MD5 hash
			hash := md5.New()
			_, err = io.Copy(hash, file)
			if err != nil {
				return fmt.Errorf("error reading file %s: %v", fullPath, err)
			}

			// Calculate the MD5 sum
			hashSum := fmt.Sprintf("%x", hash.Sum(nil))
			parts := strings.Split(entry.Name(), ".")
			parts[0] = "/" + parts[0] + "-" + string(hashSum)
			// Include the relative path in the value
			hashedFilename := filepath.Join(filepath.Dir(relativePath), strings.Join(parts, "."))
			if hashedFilename[0] == '.' { // Handle case where there's no parent directory
				hashedFilename = strings.TrimPrefix(hashedFilename, "./")
			}
			fileMap["/"+relativePath] = "/" + hashedFilename
		}
	}
	return nil
}

func copyFingerprinted(filemap map[string]string) {
	err := os.RemoveAll("assets/public")
	if err != nil {
		panic(err)
	}

	for src, dest := range filemap {
		src, dest = "assets/src"+src, "assets/public"+dest
		srcFile, err := os.Open(src)
		if err != nil {
			panic(fmt.Errorf("open src: %v", err))
		}
		defer srcFile.Close()

		dir := filepath.Dir(dest)
		err = os.MkdirAll(dir, 0755)
		if err != nil {
			panic(fmt.Errorf("mkdir all: %v", err))
		}

		destFile, err := os.Create(dest)
		if err != nil {
			panic(fmt.Errorf("create destfile: %v", err))
		}
		defer destFile.Close()

		_, err = io.Copy(destFile, srcFile)
		if err != nil {
			fmt.Println("srcFile", src)
			fmt.Println("destFile", dest)
			panic(fmt.Errorf("io.copy: %v", err))
		}

		// Ensure the file has been written to disk
		err = destFile.Sync()
		if err != nil {
			panic(err)
		}
	}
}
